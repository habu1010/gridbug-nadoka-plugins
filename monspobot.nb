# -*- coding: euc-jp -*-
# -*-ruby-*-
#
# Copyright (c) 2004-2005 SASADA Koichi <ko1 at atdot.net>
#
# This program is free software with ABSOLUTELY NO WARRANTY.
# You can re-distribute and/or modify this program under
# the same terms of the Ruby's lisence.
#
#
# $Id: samplebot.nb 130 2005-05-26 12:04:08Z ko1 $
#

# bot_file_name and BotClassName must be same name
# (BotClassName.downcase == bot_file_name)

class MonsterSpoiler
  def initialize(spo_file)
    @table = []
    @SPO_FILE = spo_file
    File.open(@SPO_FILE) do |f|
      name_lines = []
      f.each_line do |line|
        if line.strip.empty?
          name_lines.clear
          next
        end

        if /^===/ =~ line
          recallpos = f.pos
          namepos = recallpos - line.size - name_lines.map {|i| i.size}.inject(:+)
          name_line = name_lines.map {|i| i.strip}.join(" ")
          m = name_line.match(/^(?:\[.\])?\s*(?:(.+)\/)?(.+?)\s*\(.+\)$/)
          @table << {
            :num => @table.size,
            :name => m[1],
            :ename => m[2],
            :namepos => namepos,
            :recallpos => recallpos,
          }
        end
        name_lines << line
      end
    end
  end

  def select_data(search_key)
    [:name, :ename].inject([]) do |sum, symbol|
      sum + @table.select { |i| /#{search_key}/ie =~ i[symbol] }. map do |i|
        { :name => i[symbol], :num => i[:num] }
      end
    end
  end

  def get_data(num)
    File.open(@SPO_FILE) {|f|
      mon = @table[num]
      f.pos = mon[:namepos]
      name_length = mon[:recallpos] - mon[:namepos]
      f.read(name_length)
    }.map { |i| i.chomp }.join(" ")
  end

  def get_recall(num)
    recall_lines = File.open(@SPO_FILE) {|f|
      f.pos = @table[num][:recallpos]
      f.take_while { |line| !line.strip.empty? }
    }.map { |i| i.chomp }.join("")

    lastpos = 0; pos = 200
    while pos = recall_lines.index(/([。、]|\D[,.])/e, pos)
      pos += 2
      recall_lines.insert(pos, "\n")
      lastpos = pos
      pos += 200
    end

    return recall_lines
  end
end

class MonspoBot < Nadoka::NDK_Bot

  def bot_initialize
    @spoiler = {}
    @spoiler["h"] = MonsterSpoiler.new(File.expand_path(File.dirname(__FILE__) + '/band-data/heng-mon-info.spo'))
    @spoiler["x"] = MonsterSpoiler.new(File.expand_path(File.dirname(__FILE__) + '/band-data/xang-mon-info.spo'))
    @candidates = []
  end

  def on_privmsg prefix, ch, msg
    msg = msg.toeuc
    if /\Amon([x]?)(:v)?[>\s]\s*(.+)\s*/ie =~ msg
      spoiler = $1.empty? ? @spoiler["h"] : @spoiler[$1]
      verbose = $2
      key = $3

      # key が数値の場合候補からの選択を試みる
      if key =~ /^\d+$/
        idx = key.to_i - 1 
        candidates = [@candidates[idx]] if @candidates[idx]
      end

      # 合致するモンスターを検索
      candidates ||= spoiler.select_data(key)

      case
      when candidates.size > 10
        send_notice(ch, "#{key}: 候補の数が多すぎます(#{candidates.size})".tojis)
      when candidates.size > 1
        @candidates = candidates
        message = candidates.each_with_index.map { |mon, idx|
          "(#{idx + 1})#{mon[:name]}"
        }.join(" ")
        send_notice(ch, message.tojis)
      when candidates.empty?
        send_notice(ch, "#{key}: 見つかりません".tojis)
      else
        # Hit: 情報表示
        mon = candidates.first
        spoiler.get_data(mon[:num]).each do |i|
          send_notice(ch, i.rstrip.tojis)
        end
        if (verbose)
          spoiler.get_recall(mon[:num]).each do |i|
            send_notice("#{prefix.nick}", i.rstrip.tojis)
          end
        end
      end
    end
  end

end
