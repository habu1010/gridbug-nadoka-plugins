# -*-ruby; coding: utf-8 -*- vim:set ft=ruby:

class MonsterSpoiler
  def initialize(spo_file)
    @table = []
    @SPO_FILE = spo_file
    File.open(@SPO_FILE) do |f|
      namepos = nil
      name_lines = []
      f.each_line do |line|
        line = line.toutf8
        if line.strip.empty?
          name_lines.clear
          namepos = f.pos
          next
        end

        if /^===/ =~ line
          recallpos = f.pos
          name_line = name_lines.map {|i| i.strip}.join(" ")
          m = name_line.match(/^(?:\[.\])?\s*(?:(.+)\/)?(.+?)\s*\(.+\)$/)
          @table << {
            :num => @table.size,
            :name => m[1],
            :ename => m[2],
            :namepos => namepos,
            :recallpos => recallpos,
          }
        end
        name_lines << line
      end
    end
  end

  def select_data(search_key)
    [:name, :ename].inject([]) do |sum, symbol|
      sum + @table.select { |i| /#{search_key}/i =~ i[symbol] }. map do |i|
        { :name => i[symbol], :num => i[:num] }
      end
    end
  end

  def get_data(num)
    File.open(@SPO_FILE) {|f|
      mon = @table[num]
      f.pos = mon[:namepos]
      name_length = mon[:recallpos] - mon[:namepos]
      f.read(name_length).toutf8
    }.gsub("\n", ' ')
#.map { |i| i.chomp }.join(" ")
  end

  def get_recall(num)
    recall_lines = File.open(@SPO_FILE) {|f|
      f.pos = @table[num][:recallpos]
      f.take_while { |line| !line.toutf8.strip.empty? }
    }.map { |i| i.toutf8.chomp }.join("")

    lastpos = 0; pos = 0
    while pos = recall_lines.index(/([。、]|\D[,.])/, pos)
      pos += 1
      if recall_lines[lastpos..pos].tojis.size > 350
        recall_lines.insert(pos, "\n")
        pos += 1
        lastpos = pos
      end
    end

    return recall_lines
  end
end

class MonspoBot < Nadoka::NDK_Bot

  def bot_initialize
    @spoiler = {}
    @spoiler["h"] = MonsterSpoiler.new(File.expand_path(File.dirname(__FILE__) + '/band-data/heng-mon-info.spo'))
    @spoiler["x"] = MonsterSpoiler.new(File.expand_path(File.dirname(__FILE__) + '/band-data/xang-mon-info.spo'))
    @candidates = []
  end

  def on_privmsg prefix, ch, msg
    if /\Amon([x]?)(:v)?[>\s]\s*(.+)\s*/i =~ msg.toutf8
      spoiler = $1.empty? ? @spoiler["h"] : @spoiler[$1]
      verbose = $2
      key = $3

      # key が数値の場合候補からの選択を試みる
      if key =~ /^\d+$/
        idx = key.to_i - 1 
        candidates = [@candidates[idx]] if @candidates[idx]
      end

      # 合致するモンスターを検索
      candidates ||= spoiler.select_data(key)

      case
      when candidates.size > 10
        send_notice(ch, "#{key}: 候補の数が多すぎます(#{candidates.size})".tojis)
      when candidates.size > 1
        @candidates = candidates
        message = candidates.each_with_index.map { |mon, idx|
          "(#{idx + 1})#{mon[:name]}"
        }.join(" ")
        send_notice(ch, message.tojis)
      when candidates.empty?
        send_notice(ch, "#{key}: 見つかりません".tojis)
      else
        # Hit: 情報表示
        mon = candidates.first
        spoiler.get_data(mon[:num]).lines do |i|
          send_notice(ch, i.rstrip.tojis)
        end
        if (verbose)
          spoiler.get_recall(mon[:num]).lines do |i|
            send_notice("#{prefix.nick}", i.rstrip.tojis)
          end
        end
      end
    end
  end

end
